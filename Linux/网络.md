[TOC]

# 网络编程



## 字节序（大小端）

```
port:8000 小端：0x1f80 大端:0x801f（地址左高右低，平时写的是小端）

#include <arpa/inet.h>
uint32_t htonl(uint32_t hostint32) // host->net
uint16_t htons(uint16_t hostint16) // host->net
uint32_t ntohl(uint32_t netint32)  // net->host
uint16_t ntohs(uint16_t netint16)  // net->host
```

简介：小端，低字节->低地址；大端，低字节->高地址



## 地址格式

```
#include <arpa/inet.h>
// 点分十进制 -> 4B整数
// char*     -> int
// 主机字节序 -> 网络字节序
int inet_pton(int domain,
					char *restrict str,		// 输入
					void *restrict addr);	// 输出
// 网络字节序 -> 主机字节序
// int       -> char*
// 4B整数    -> 点分十进制 
const char *inet_ntop(int domain,	// ipv4 or ipv6
					const void *restrict addr,	// 输入
					char *restrict str,	// 输出
					socklen_t size);	//
```

简介：



## 套接字（Socket：网络IPC）

```
#include <sys/socket.h>
// 创建套接字，返回监听套接口sockfd
int socket (int domain,	// ipv4: AF_INET ipv6: AF_INET6
			int type,	// TCP: SOCK_STREAM UDP: SOCK_DGRAM
			int protocal);	// 通常为0
int close (int fd)； // 关闭输入/输出流，关闭了sockfd，socket连接未破坏
int shutdown(int sockfd, int how); // 半关闭，所有线程都不能用，读or写orAll，破坏socket连接

// 绑定套接字和本地ip地址
int bind(int sockfd, const struct sockaddr *addr, socklen_t len); // addr{family，ip，port}

// 服务器：
int listen(int sockfd, int num); // num表示能够同时接受多少连接
int accept(int sockfd,			// 接受客户机发起的connect，返回连接套接口sockfd，
			struct sockaddr *restrict addr, // OUT：客户机的ip和port
			socklen_t *restrict len); // OUT：结构体大小
// 客户机：
int connect(int sockfd, const struct sockaddr *addr, socklen_t len);

// 读写：
ssize_t read(int fd, void *buf, size_t nbytes);
ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags); // 返回0结束，-1出错
ssize_t recvfrom(int sockfd, void *restrict buf, size_t len, int flags,
				struct sockaddr *restrict addr,
				socketlen_t *restrict addrlen); // 可获得客户机地址信息
ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);

ssize_t write(int fd, const void *buf, size_t nbytes);
ssize_t send(int sockfd, const void *buf, size_t nbytes, int flags);
ssize_t sendto(int sockfd, const void *buf, size_t nbytes, int flags,
				const struct sockaddr *destaddr, socklen_t destlen);
ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);

```

<img src="appendix\tcp_socket.png" style="zoom: 80%;" />



------

*参考资料：*

- UNIX高级环境编程 P477，P487
- https://www.bilibili.com/video/BV1DA411q7ip
- <https://www.bilibili.com/video/BV1Xp4y1S7BL>





# 网络协议

<img src="appendix\osi7.png" style="zoom:50%;" />

<img src="appendix\network.png" style="zoom:75%;" />

## IP

简介：

## TCP

简介：面向连接、可靠的、基于虚电路的、传输协议，适合大量数据传输，慢

### 三次握手

<img src="appendix\3shake.png" style="zoom:50%;" />

简介：

- 第一次：客户机发含SYN位，seq = x的包到服务器。（客 -> SYN_SEND）

- 第二次：服务器发含SYN位和ACK位，seq = y，ack = x + 1的包到客户机。（服 -> SYN_RECV）

- 第三次：客户机发送含ACK位，ack = y + 1的包到服务器。（客 -> ESTABLISH，服 -> ESTABLISH）

  

### 四次挥手

<img src="appendix\4wave.png" style="zoom:50%;" />

简介：

- 第一次：客户机发含FIN位，seq = u的包到服务器。（客 -> FIN_WAIT_1）
- 第二次：服务器发含ACK位，ack = u + 1的包到服务器。（服 -> CLOSE_WAIT，客 -> FIN_WAIT_2）
  - 此处有等待
- 第三次：服务器发含FIN，seq = w的包到客户机。（服 -> LAST_ACK，客 -> TIME_WAIT）
  - 此处有等待
- 第四次：客户机发含ACK位，ack = w + 1的包到客户机。（服 -> CLOSED）



> **附tcpdump抓包：**
>
> ![](appendix\3s4w.png)



> ### **TCP/UDP：**
>
> | 协议 | 连接方式   | 可靠性                                 | 内容                   |
> | ---- | ---------- | -------------------------------------- | ---------------------- |
> | TCP  | 面向连接   | 可靠（序号、重传、流量控制、拥塞控制） | 面向字节流，可分割重组 |
> | UDP  | 面向无连接 | 不保证可靠，尽力传输                   | 面向数据报             |
>
> 
>
> ### **三次握手？**
>
> 避免**服务器到客户机的ACK**（第三次握手）延迟或丢失，导致**服务器等待数据**，**客户机**未收到ack，**不发送数据**，造成**服务器**端资源**浪费**
>
> 
>
> ### **四次挥手？**
>
> 被动方将“**确认对方关闭**”（第二次挥手）的ack和自己“**关闭己方连接**”（第三次挥手）的两个操作分两次进行（也会出现合并的情况，消息个数4->3）
>
> 
>
> ### **TIME_WAIT状态？**
>
> 防止**第四次挥手ACK延迟或丢失**，对端消息超时再次发送FIN消息时，tcp连接已断开，返RST消息导致对端进入错误状态；第四次挥手ACK发送之后**等待2MSL**（Maximum Segment Life）**再关闭**tcp连接，则可以正确收到对端超时重发的FIN消息。
>
> 
>
> ### **状态转换？**
>
> - 客户端：SYN_SENT -> ESTABLISHED -> FIN_WAIT_1 -> FIN_WAIT_2 -> TIME_WAIT
> - 服务端：LISTEN -> SYN_RCVD -> ESTABLISHED -> CLOSE_WAIT -> LAST_ACK -> CLOSED



## HTTP





------

*参考资料：*

- https://www.bilibili.com/video/av370988107?p=3
- https://www.cnblogs.com/xiaoYu3328/p/5005003.html





# 高级IO



## 非/阻塞IO



## 多路复用

### poll

### epoll



## 异步IO