[TOC]

# 网络编程



## 字节序（大小端）

```
port:8000 小端：0x1f80 大端:0x801f（地址左高右低，平时写的是小端）

#include <arpa/inet.h>
uint32_t htonl(uint32_t hostint32) // host->net
uint16_t htons(uint16_t hostint16) // host->net
uint32_t ntohl(uint32_t netint32)  // net->host
uint16_t ntohs(uint16_t netint16)  // net->host
```

简介：小端，低字节->低地址；大端，低字节->高地址



## 地址格式

```
#include <arpa/inet.h>
// 点分十进制 -> 4B整数
// char*     -> int
// 主机字节序 -> 网络字节序
int inet_pton(int domain,
					char *restrict str,		// 输入
					void *restrict addr);	// 输出
// 网络字节序 -> 主机字节序
// int       -> char*
// 4B整数    -> 点分十进制 
const char *inet_ntop(int domain,	// ipv4 or ipv6
					const void *restrict addr,	// 输入
					char *restrict str,	// 输出
					socklen_t size);	//
```

简介：



## 套接字（Socket：网络IPC）

```
#include <sys/socket.h>
// 创建套接字，返回监听套接口sockfd
int socket (int domain,	// ipv4: AF_INET ipv6: AF_INET6
			int type,	// TCP: SOCK_STREAM UDP: SOCK_DGRAM
			int protocal);	// 通常为0
int close (int fd)； // 关闭输入/输出流，关闭了sockfd，socket连接未破坏
int shutdown(int sockfd, int how); // 半关闭，所有线程都不能用，读or写orAll，破坏socket连接

// 绑定套接字和本地ip地址
int bind(int sockfd, const struct sockaddr *addr, socklen_t len); // addr{family，ip，port}

// 服务器：
int listen(int sockfd, int num); // num表示能够同时接受多少连接
int accept(int sockfd,			// 接受客户机发起的connect，返回连接套接口sockfd，
			struct sockaddr *restrict addr, // OUT：客户机的ip和port
			socklen_t *restrict len); // OUT：结构体大小
// 客户机：
int connect(int sockfd, const struct sockaddr *addr, socklen_t len);

// 读写：
ssize_t read(int fd, void *buf, size_t nbytes);
ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags); // 返回0结束，-1出错
ssize_t recvfrom(int sockfd, void *restrict buf, size_t len, int flags,
				struct sockaddr *restrict addr,
				socketlen_t *restrict addrlen); // 可获得客户机地址信息
ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);

ssize_t write(int fd, const void *buf, size_t nbytes);
ssize_t send(int sockfd, const void *buf, size_t nbytes, int flags);
ssize_t sendto(int sockfd, const void *buf, size_t nbytes, int flags,
				const struct sockaddr *destaddr, socklen_t destlen);
ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);

```

<img src="appendix\tcp_socket.png" style="zoom: 80%;" />



------

*参考资料：*

- UNIX高级环境编程 P477，P487
- https://www.bilibili.com/video/BV1DA411q7ip
- <https://www.bilibili.com/video/BV1Xp4y1S7BL>





# 网络协议

<img src="appendix\osi7.png" style="zoom:50%;" />

<img src="appendix\network.png" style="zoom:75%;" />



## TCP/IP

简介：面向连接、可靠的、基于虚电路的、传输协议，适合大量数据传输，慢

### 三次握手

<img src="appendix\3shake.png" style="zoom:50%;" />

简介：

- 第一次：客户机发含SYN位，seq = x的包到服务器。（客 -> SYN_SEND）

- 第二次：服务器发含SYN位和ACK位，seq = y，ack = x + 1的包到客户机。（服 -> SYN_RECV）

- 第三次：客户机发送含ACK位，ack = y + 1的包到服务器。（客 -> ESTABLISH，服 -> ESTABLISH）

  

### 四次挥手

<img src="appendix\4wave.png" style="zoom:50%;" />

简介：

- 第一次：客户机发含FIN位，seq = u的包到服务器。（客 -> FIN_WAIT_1）
- 第二次：服务器发含ACK位，ack = u + 1的包到服务器。（服 -> CLOSE_WAIT，客 -> FIN_WAIT_2）
  - 此处有等待
- 第三次：服务器发含FIN，seq = w的包到客户机。（服 -> LAST_ACK，客 -> TIME_WAIT）
  - 此处有等待
- 第四次：客户机发含ACK位，ack = w + 1的包到客户机。（服 -> CLOSED）



> **附tcpdump抓包：**
>
> ![](appendix\3s4w.png)



> ### **TCP/UDP：**
>
> | 协议 | 连接方式   | 可靠性                                      | 内容                   |
> | ---- | ---------- | ------------------------------------------- | ---------------------- |
> | TCP  | 面向连接   | 可靠（序号、重传、流量控制、拥塞控制、CRC） | 面向字节流，可分割重组 |
> | UDP  | 面向无连接 | 不保证可靠，尽力传输                        | 面向数据报             |
>
> 
>
> ### **三次握手？**
>
> 避免**服务器到客户机的ACK**（第三次握手）延迟或丢失，导致**服务器等待数据**，**客户机**未收到ack，**不发送数据**，造成**服务器**端资源**浪费**
>
> 
>
> ### **四次挥手？**
>
> 被动方将“**确认对方关闭**”（第二次挥手）的ack和自己“**关闭己方连接**”（第三次挥手）的两个操作分两次进行（也会出现合并的情况，消息个数4->3）
>
> 
>
> ### **TIME_WAIT状态？**
>
> 防止**第四次挥手ACK延迟或丢失**，对端消息超时再次发送FIN消息时，tcp连接已断开，返RST消息（要求对方重新建立连接）导致对端进入错误状态；第四次挥手ACK发送之后**等待2MSL**（Maximum Segment Life）**再关闭**tcp连接，则可以正确收到对端超时重发的FIN消息。
>
> 
>
> ### **状态转换？**
>
> - 客户端：SYN_SENT -> ESTABLISHED -> FIN_WAIT_1 -> FIN_WAIT_2 -> TIME_WAIT
> - 服务端：LISTEN -> SYN_RCVD -> ESTABLISHED -> CLOSE_WAIT -> LAST_ACK -> CLOSED



## HTTP

### HTTP版本

简介：无状态、基于请求和响应的、常基于TCP/IP协议的、在应用层的、超文本传输协议

| 版本     | 产生时间 | 内容                                                         | 发展现状           |
| -------- | -------- | ------------------------------------------------------------ | ------------------ |
| HTTP/0.9 | 1991年   | 不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求 | 没有作为正式的标准 |
| HTTP/1.0 | 1996年   | 传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令 | 正式作为标准       |
| HTTP/1.1 | 1997年   | 持久连接(**长连接**)、节约带宽、HOST域、**管道机制**、**分块传输编码** | 2015年前使用最广泛 |
| HTTP/2   | 2015年   | **多路复用**、服务器推送、头信息压缩、二进制协议等           | 逐渐覆盖市场       |

<img src="appendix\http2multiplex.jpg" style="zoom:33%;" />



### HTTP报文

![](appendix\http_format.png)



### HTTP请求方法和状态码

> **常见请求方法：**
>
> - GET:请求指定的页面信息，请求中**无实体主体**；**多用于查询**，添加再在URL后
> - POST:向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。**数据**被包含在**请求实体主体**中。POST请求可能会导致新的资源的建立和/或已有资源的修改。**多用于提交**，请求在报文内部
> - HEAD:类似于get请求，只不过**返回的响应**中没有**实体主体**内容，用于**获取报头**
> - PUT:从客户端向服务器传送的数据取代指定的文档的内容。
> - DELETE:请求服务器删除指定的页面。
>
> **状态码分类**：
>
> - 1XX- 信息型，服务器收到请求，需要请求者继续操作。
> - 2XX- 成功型，请求成功收到，理解并处理。
> - 3XX - 重定向，需要进一步的操作以完成请求。
> - 4XX - 客户端错误，请求包含语法错误或无法完成请求。
> - 5XX - 服务器错误，服务器在处理请求的过程中发生了错误。
>
> **常见状态码**：
>
> - 200 OK - 客户端请求成功
> - 301 - 资源（网页等）被永久转移到其它URL
> - 302 - 临时跳转
> - 400 Bad Request - 客户端请求有语法错误，不能被服务器所理解
> - 401 Unauthorized - 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
> - 404 - 请求资源不存在，可能是输入了错误的URL
> - 500 - 服务器内部发生了不可预期的错误
> - 503 Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。
>
> 

<img src="appendix\http_comm.jpg" style="zoom: 67%;" />



##  HTTPS

简介：HTTPS是身披SSL外壳的HTTP。HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。

PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。



### HTTPS建链过程（四次握手）

<img src="appendix\https_ssl.png" style="zoom: 80%;" />

1. 客户端发送请求：1条消息
   - **Client Hello**: 连接服务器**433端口**，发送**SSL版本**和**支持的加密算法列表**
2. 服务端响应：合并1条 or 4条单独消息
   - **Sever Hello**：
   - **Certificate**：
   - **Server Key Exchange**：
   - **Server Hello Done**：
3. 客户端检验CA后，生成公钥，通过服务端公钥加密后发送：1条or3条单独消息
   - **Client Key Exchange**：
   - **Change Chiper Spec**：
   - **Encrypted Handshake Message**：
4. 服务器的最后回应：1条or3条单独消息
   - **New Session Ticket**：
   - **Change Chiper Spec**：
   - **Encrypted Handshake Message**：

> **Key Exchange**：发送本端公钥
>
> **Change Chiper Spec**：告知对端本段已准备好加密
>
> **Encrypted Handshake Message**：客户端和服务器加上pre master secret **3个随机数**生成的加密算法**密钥**，**进一步加密的报文**



## HTTP vs HTTPS

> HTTP和HTTPS的优劣：
>
> HTTP：
>
> - **无状态**：对事物处理没有“记忆”能力
> - **无连接**：HTTP/1.1之前，无状态，每次请求都需要TCP三次握手四次挥手和服务器建立连接；资源浪费
> - 基于**请求和响应**
> - 简单快速灵活
> - 劣：使用**明文**，不会对对端进行确认，**无法保护数据可信和完整**
>
> HTTPS：
>
> - **内容加密**：采用混合加密技术，中间者无法直接查看明文内容
> - **身份验证**：通过证书认证客户端访问的是自己的服务器
> - **保护数据可信和完整**：防止传输的内容被中间人冒充或者篡改
>
> - 劣：**多次握手**，页面加载**时间长**60%
> - 劣：**连接缓存不**如http**高效**
> - 劣：**SSL**证书**花钱**
> - 劣：**SSL**加密算法**消耗cpu**计算资源





------

*参考资料：*

- https://www.bilibili.com/video/av370988107?p=3
- https://www.cnblogs.com/xiaoYu3328/p/5005003.html
- https://www.bilibili.com/video/BV1rt4y1m7o5/?spm_id_from=333.788.videocard.1
- https://zhuanlan.zhihu.com/p/72616216
- https://www.jianshu.com/p/cf2f86bc597a
- https://www.bilibili.com/video/BV1bt4y1y7XD?from=search&seid=15815187373145764713





# 高级IO



## 非/阻塞IO



## 多路复用

### poll

### epoll



## 异步IO