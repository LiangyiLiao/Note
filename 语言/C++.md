# 重载 重写 重定义

**重载：overload**  **类内**相同**函数名**不同**参数列表**

- **函数名相同**

- **参数列表不同**

- **不依靠返回值**区分

- virtual也是重载的一个版本

- （无参构造，有参构造，拷贝构造）是重载的应用

  

**重写：override**  **子类继承父类**时，重写父类中的方法

- **不能是static**的（只能继承），**必须是virtual**的

- 必须有相同的**返回值类型，名称，参数列表**

- 可以将pivate重写为protect public

  

**重定义：redefining** （**隐藏**） 子类对父类的成员函数进行重新型定义

- 函数名必须相同
- 返回值，参数列表无要求



# 封装 继承 多态

**封装**：保护或者防止代码（数据）被无意中破坏，保护成员变量不让类以外的程序直接访问和修改，隐藏方法细节；

**继承**：重用代码，节省开发时间；

**多态**：通过“**动态绑定**”技术，在**代码执行期间判断**所引用的对象的实际类型，根据实际类型**调用相应的方法**；（**基类指针指向子类对象**，在代码**执行的时候选择调用的成员函数**）

​		3个条件：存在继承关系，子类重写父类方法，父类指针指向子类对象；



> **多态的实现原理：虚表指针 虚函数表**
>
> 虚表指针：在**类内存地址最前端**，存放虚函数表地址
>
> 虚函数表：每一个有**虚函数**的**类**及其**子类**，都有一个虚函数表



# 引用 指针

引用：必须被初始化，引用不可更改，不分配存储空间，不能引用空值

指针：不一定要初始化，指针指向可以更改，初始化时分配内存空间，可以指向空值

> **引用更好，没有空指针，野指针，内存泄漏踩踏等问题**



# 指针* 引用& 解引用* 取地址&

指针：指向一块内存，保存的是内存的地址；

引用：是变量的别名，本质是引用该变量的地址；

解引用：取指针指向地址的内容；

取地址：取变量在内存中的地址；



# 变量 声明 定义

声明：不分配地址，extern表面在**文件外**或**文件后**面部分定义

定义：分配内存地址，只定义一次



# static关键字

C：

- 全局静态变量：限定作用域为文件内，另一文件不可见
- 局部静态变量：限作用域与局部变量相同，但是空间在程序开始时分配，结束后释放
- 静态函数：限定作用域为文件内，另一文件不可见

C++：

- 静态成员变量：类的各个对象共享
- 静态成员函数：函数不能访问或修改任何**非static变量**，没有this指针，不针对某个对象调用

> static定义的变量分配在**静态区**，所以变量默认值为0，程序**开始时分配**空间，程序**结束时释放**



# extern关键字

表明**变量**或者**函数** **定义在其他文件中**，编译器遇到extern在其他文件中寻找定义



# malloc new

new delete：操作符，可以重载，调用构造析构函数，返回具体指针类型

malloc free：函数，可以重写，仅仅分配内存，返回void类型指针



# sizeof strlen

sizeof：运算符，编译时计算，可以是数据类型和变量，单位是内存大小Byte

strlen：库函数，运行时计算，只能是‘\0’结尾的字符串，单位是字符串长度



# define const inline

define：**没有数据类型和检查**，**预编译**时替换

const：有数据类型和检查，确保 **值，函数参数，函数返回值** 不被修改

inline：在**运行期间展开**，但是**有类型检查**

> const int a;//a是一个常整型数
>
> int const a;//a是一个常整型数
>
> const int *a;//a是一个指向常整型数的指针
>
> int * const a;//a是一个指向整型数的常指针
>
> int const * a;//a同上



# 拷贝构造函数 赋值运算符

拷贝构造：生成新的对象

赋值运算符：需要检查类型是否一致，并且释放被复制的对象内存

> 类中有指针类型的成员变量时，一定要重写拷贝构造函数和赋值运算符（深拷贝），不要使用默认的（浅拷贝）



# 数组名 指针

数组名并不是真正意义上的指针，比指针涵盖内容多，当数组名当做参数传递时，退化为指针；



> a) int a; //一个整型数
>
> b) int *a; //一个指向整型数的指针
>
> c) int **a; //一个指向指针的的指针，它指向的指针是指向一个整型数
>
> d) int a[10]; //一个有10个整型数的数组
>
> e) int *a[10]; //一个有10个指针的数组，该指针是指向一个整型数的
>
> f) int (*a)[10]; //一个指向有10个整型数数组的指针
>
> g) int (*a)(int); //一个指向函数的指针，该函数有一个整型参数并返回一个整型数
>
> h) int (*a[10])(int); // 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数



# C++默认成员函数

默认构造函数、析构函数、复制构造函数、赋值函数



# 智能指针

https://www.jianshu.com/p/e4919f1c3a28

shared_ptr: 多个指针指向相同的对象，使用引用计数管理

- 尽量不使用裸指针创建shared_ptr
- 避免循环引用导致内存泄漏（使用weak_ptr解决）

unique_ptr:独占资源，不允许多个指针指向

weak_ptr:解决循环引用问题，可以通过weak_ptr创建shared_ptr但是不增加（强）引用计数，



# 强制类型转化





# STL

https://note.youdao.com/ynoteshare1/index.html?id=824d033bef28cf83ec104cccce9d9d2a&type=notebook#/WEB38ca33de8339d798a4e37a3a4443f99e

**vector**：连续内存空间，只增长不减小，2倍扩容并拷贝

**list**：环形双向链表

**deque**：vector+一段段连续内存空间

**map**：

**multimap**：

**set**：

**multiset**：



## 内存分配策略

- 大于128 bytes使用malloc来分配内存
- 小于128 bytes使用memory pool来分配内存，维护一个free-list 管理8 16 24。。。128Byte的空闲块