数据结构与算法：
- 给定一个二叉树，返回其按层次遍历的节点值
- 图上的深度优先遍历算法
- 二叉树的非递归遍历
- 哈希表解决冲突的方式，装载因子（load factor）
    - 开放地址法（哈希值加增量，线性探测，二次探测，伪随机数探测法）
    - 再哈希法（换第二个哈希函数）
    - 链地址法（链表连接）
- 排序算法，快速排序、堆排序
    - 快速排序：每一轮排序将pivot置于正确的位置，左右分别都小于或者大于pivot，递归排序左右序列
    - 通过构造大小顶堆，不断pop堆顶并调整堆，使得输出有序
- 判断单链表是否有环
    - 快慢指针
- 如何判断两个单链表是否相交，是否有环（分3种情况）
    - 两指针遍历并交换遍历，判断是否有相同的节点；
- 区间查询，线段树问题
        给你一些数，组成一个序列，如[1 4 2 3]，有两种操做: 操作一:给序列的第i个数加上X (X可以为负数) 操作二:询问序列中最大的数是什么? 格式query(start, end)，表示区间[start, end]内，最大值是多少?
- topK问题以及动态的topK问题
    - 全局排序<局部排序**冒泡**<单个排序**堆排**<减治法**快排**
- 内存限制在2G，100亿个int8类型的数字排序
    - map reduce
- 内存限制在2G，100亿个int64类型的数字排序
- 单链表反转（链表有环）
- 给定一个整数，求二进制表示中1的个数；给定一个浮点数呢


Golang
- 哈希表，解决哈希冲突的方法，什么时候扩容，扩容的方案
  - **load factor 6.5**，触发扩容至**2倍**，访问旧桶时触发**增量迁移**到新桶
  -  使用了**太多溢出桶**，触发创建**新的更大的溢出桶**保存数据
- interface{}和[]interface{}区别
- channel相关
- goroutine调度器
- 内存分配和GC


操作系统：
- 进程、线程、协程介绍
  - **进程有独立的内存空间，进程间切换开销大，但稳定安全，系统资源分配和调度基本单位**
  - **线程只拥有必不可少的少量资源（栈、寄存器、虚拟内存、fd），与同进程内线程共享资源，CPU调度和分派的基本单位**
  - **协程是轻量级线程，有自己的寄存器上下文和栈，上下文切换最快；**
- 进程间通信方式，system v语义下，信号量、消息队列、共享内存，优缺点
  - **进程：管道，消息队列，共享内存，信号量**
  - **线程：锁，条件变量，内存屏障**
- 孤儿进程和僵尸进程出现的情况，原因，危害
僵尸进程：进程终止时，1）程序必须由外部杀死（通过发送**SIGTERM或SIGKILL**信号）；进程的**父进程**在子进程终止时必须**调用wait4系统调用**，向内核证实父进程已经确认子进程的终结。
- 并发编程的模型，锁和多线程  
- io多路复用，select、poll、epoll
  - 
- 堆和栈的区别
- shell命令（基础命令、抓包命令、lsof、ip a、netstat、strace命令、查看内存使用、网络情况、端口）
rm一个文件之后，文件是否被删除
- docker相关的知识（基本命令、打包和加载、原理）
- docker 技术与虚拟机技术有何不同
- 什么是半虚拟化
- k8s相关的知识（基本命令、服务管理、文件拷贝）
- 创建子进程的方式
- 一个进程中线程崩了，该进程会崩溃吗？为什么
- 进程状态，什么情况下sleep的进程不能被唤醒，SIGKILL




网络：
- TCP协议相关3次握手，4次挥手，TCP状态转移，什么时候出现TIME_WAIT
  - **第四次挥手之后出现TIME_WAIT，两个MSL，保证对端在没有收到第四次挥手消息触发消息重发时本端能正确处理请求；**
- IP协议相关
- 短链接的原理。如t.cn如何映射到一个真正的域名。
  - **短链接通过重定向到另一个完整的长链接上，一般通过长链接做哈希或者使用发号器实现转换**
- SQL注入，SQL盲注
- 几种XSS
- 软件的破解逆向
- gRPC相关：

数据库相关：
- 事务四大特性（ACID）

  -  原子性(atomic)：一系列的操作具有不可分割性，要么完全执行，要么完全不执行。
  - 一致性(consistency)：操作的前后满足同样的规则(约束条件）。
  -  隔离性(isolation)：在事务运行的过程中。事务内的数据对外的可见性和可操作性（必需由数据库的支持）
  - 稳定性(durability)：保证数据在事务的操作一旦提交完成，就是永久性存储的。

- 数据库隔离级别，每个级别会引发什么问题，mysql默认是哪个级别

  - repeatable read

- 有哪些锁（乐观锁悲观锁），select时怎么加排它锁

- MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景

  - **MyISAM：表锁，适用于大量SELECT**
  - **InnoDB：支持事务、行锁、索引、外键，适用于大量INSERT和UPDATE**

- 数据库的优化（从sql语句优化和索引两个部分回答）

- 索引有B+索引和hash索引，各自的区别

- B+索引数据结构，和B树的区别7

- 索引的分类（主键索引、唯一索引），最左前缀原则，哪些情况索引会失效

- 聚集索引和非聚集索引区别。

- 关系型数据库和非关系型数据库区别

- 了解nosql

- 数据库三范式，根据某个场景设计数据表（可以通过手绘ER图）

- 数据库的主从复制

- 使用explain优化sql和索引

  - 

- long_query怎么解决

  - 开启慢查询日志，分析哪些查询语句超时

    ```mysql
    set global slow_query_log='ON'; 
    set global slow_query_log_file='/usr/local/mysql/data/slow.log';
    set global long_query_time=1;
    ```

    

- 内连接、外连接、交叉连接、笛卡儿积等

- like语句中可以使用哪些通配符。

Redis:
- redis数据结构由哪些
- Redis 为什么是单线程的？
- redis队列应用场景

分布式系统：
- 一致性哈希
- 消息队列kafka


智力题：
- 已知一随机发生器，产生0的概率是p，产生1的概率是1-p，现在要你构造一个发生器，使得它产生0和1的概率均为1/2

- 已知一随机发生器，产生的数字的分布不清楚，现在要你构造一个发生器，使得它产生0和1的概率均为1/2。
【分析】使用该随机发生器产生随机数a，b，有以下3种情况：(1)a<b, (2) a == b, (3) a>b，其中情况（1）和（3）是对称的，发生的概率相等，只需要将这两种情况分别映射到0和1即可，其中遇到a==b时忽略。

- 已知有个rand7()的函数，返回1到7随机自然数，让利用这个rand7()构造rand10()随机1~10。
【分析】
1）要保证rand10()在整数1-10的均匀分布，可以构造一个1-10*n的均匀分布的随机整数区间（n为任何正整数）。假设x是这个1-10*n区间上的一个随机整数，那么x%10+1就是均匀分布在1-10区间上的整数。
2）接下来利用(rand7()-1)*7+rand7()构造出均匀分布在1-49的随机数：
首先rand7()-1得到一个离散整数集合{0，1，2，3，4，5，6}，其中每个整数的出现概率都是1/7。那么(rand7()-1)*7得到一个离散整数集合A={0，7，14，21，28，35，42}，其中每个整数的出现概率也都是1/7。而rand7()得到的集合B={1，2，3，4，5，6，7}中每个整数出现的概率也是1/7。显然集合A和B中任何两个元素组合可以与1-49之间的一个整数一一对应，也就是说1-49之间的任何一个数，可以唯一确定A和B中两个元素的一种组合方式，反过来也成立。由于A和B中元素可以看成是独立事件，根据独立事件的概率公式P(AB)=P(A)P(B)，得到每个组合的概率是1/7*1/7=1/49。因此(rand7()-1)*7+rand7()生成的整数均匀分布在1-49之间，每个数的概率都是1/49。
3）由于出现的每个数的出现都是相对独立的，所以剔除41-49后剩下1-40也应该是均匀分布。


项目相关：

问我项目的难点在哪里，做了哪些改进，每个改进提升了多少的效果


Python相关面试题：
0.函数装饰器有什么作用？请列举说明？
1.Python 垃圾回收机制？
2.魔法函数 __call__怎么使用?
3.如何判断一个对象是函数还是方法？
4.@classmethod 和@staticmethod 用法和区别
5.Python 中的接口如何实现？
6.Python 中的反射了解么?
7.metaclass 作用？以及应用场景？
8.hasattr() getattr() setattr()的用法
9.请列举你知道的 Python 的魔法方法及用途。
10.如何知道一个 Python 对象的类型？
11.Python 的传参是传值还是传址？
12.Python 中的元类(metaclass)使用举例
13.简述 any()和 all()方法
14.filter 方法求出列表所有奇数并构造新列表，a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
15.什么是猴子补丁？
16.在 Python 中是如何管理内存的？
17.当退出 Python 时是否释放所有内存分配？

系统及工具知识
linux系统及shell工具
 • 解释shell环境变量。
 • 解释文件系统软链接与硬链接。ln命令。
 • 解释进程、线程、协程
 • 如何查看某进程当前占用的内存大小
 • 某服务在持续生成日志，如何实时跟踪查看最新日志以进行问题排查。
 • 各种命令行工具：vim、cat、ps、tail、head、sed、awk、netstat、uniq、sort、grep等。
 • linux创建子进程方式。
git
 • git 解决什么问题
 • 名词解释：HEAD，工作区，暂存区，分支，本地仓库，远程仓库。
 • 描述一个简单的开发提交流程。
 • 如何快速把一个分支上的某个补丁commit添加到另外一个功能分支上。
 • 提交cr后出现冲突如何处理。
 • 如何撤销一个commit。本地/远程仓库。
docker
 • docker容器解决什么问题，与虚拟机的区别。优缺点。
 • docker服务架构？
 • 命名空间隔离实现机制？
 • 查看镜像列表
 • 删除镜像
 • 查看容器列表
 • 创建并进入一个新的容器
 • 进入一个已有的容器
 • 容器内能访问到宿主机的进程/文件吗？数据卷如何挂载？多个容器可以共享么？
 • 网络端口映射
 • 删除一个容器
 • 制作一个镜像
 • 容器优先级/oom
k8s
 • k8s解决什么问题
 • job和deployment、relicaset区别
 • 查看pod/rs/deployment列表
 • 删除一个pod(pod删除后会自动重启吗)
 • 查看pod中容器的日志
 • 如何指定pod运行在某个/某类节点上
 • controller/operator
 • k8s服务架构
语言代码能力与数据结构算法
Java
 • 谈谈final, finally, finalize的区别。
final：修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载 。
finally：再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。
finalize：方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。
 • String s = new String("xyz");创建了几个String Object?
两个对象，一个是“xyx”,一个是指向“xyx”的引用对象s。
 • Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?
方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。
 • 普通类和抽象类有哪些区别？
普通类不能包含抽象方法，抽象类可以包含抽象方法。
抽象类是不能被实例化的，就是不能用new调出构造方法创建对象，普通类可以直接实例化。
如果一个类继承于抽象类，则该子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。
 • 现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？
可以用join方法实现。
 • 在java中wait和sleep方法的不同？
最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。
sleep()方法可以在任何地方使用；wait()方法则只能在同步方法或同步块中使用；
sleep()是线程线程类（Thread）的方法，到时间自动恢复；wait()是Object的方法，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，才会进入锁池，不再次获得对象锁才会进入运行状态
 • 描述一下单例模式，优缺点，适用场景。
c/cpp
golang
python
数据结构与算法
 • check回文字符串
 • 链表和数组区别、优缺点
 • 链表倒转
 • 二叉查找树
 • 二叉树按层遍历
 • 硬盘上1T大小的文件保存可排序数据，计算机内存只有4G，如何排序。
 • 桶排序。
 • 图相关算法。拓朴排序结果是唯一的么。
计算机网络
 • 简述用户在浏览器浏览一个页面的过程中都发生了什么
 • TCP和UDP区别。优缺点及适用场景。
机器/深度学习
 • 机器学习可以解决哪些问题。回归类

智力题
 • 已知一随机发生器，产生0的概率是p，产生1的概率是1-p，现在要你构造一个发生器，使得它产生0和1的概率均为1/2
 • 已知一随机发生器，产生的数字的分布不清楚，现在要你构造一个发生器，使得它产生0和1的概率均为1/2。
``【分析】使用该随机发生器产生随机数a，b，有以下3种情况：(1)ab，其中情况（1）和（3）是对称的，发生的概率相等，只需要将这两种情况分别映射到0和1即可，其中遇到a==b时忽略。


别考排序了同学们。能把list，hashmap，二叉树讲清楚就行。spark提两个问题，pandas提个问题，rest服务接口，网络知识，异常处理，orm使用，编码风格，操作系统进程，各种并发控制，关系型数据怎么反范式的用维护成本低，redis，hive，hbase，cassandra使用场景这些实际问题考一考

大数据面经：

1. NN和DN。
2. HA的实现
3. zookeeper的原理，zk是如何保证一致性的，zk是如何判断session超时，connection超时的。如何触发回调。
4. client和HDFS文件的读写过程，延迟太高，怎么解决。我当时脑子一蒙，直接说了设计的就是高吞吐量的文件系统。
5. yarn的结构，RM和NM的交互，如何分配任务的。
6. yarn在什么层面调度，和k8s和mesos有什么区别，内存调度是什么怎么调度的，如果考虑CPU怎么调度的。如何实现隔离的，Control group 和Namespace是怎么回事。
7. mapReduce为什么需要Shuffle这一步
8. MapReduce全过程，分片怎么读的，为什么用快排，换别的行不行，多路归并怎么实现的，环形缓冲区怎么实现的。